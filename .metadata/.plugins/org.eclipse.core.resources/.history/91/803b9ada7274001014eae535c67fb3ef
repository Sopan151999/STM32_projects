/*
 * Hdl_CAN.c
 *
 *  Created on: Aug 5, 2025
 *      Author: sopan
 */


#include "Hdl_CAN.h"
#include "globle_data.h"
#include "string.h"
// Global variables
CAN_TxHeaderTypeDef TxHeader;
CAN_RxHeaderTypeDef RxHeader;
uint8_t TxData[8];
uint8_t RxData[8];
uint32_t TxMailbox;
volatile uint8_t CAN_MessageReceived = 0;

extern CAN_HandleTypeDef hcan;

// === CAN Initialization ===
void CAN_Init(void)
{
    HAL_CAN_Start(&hcan);
    HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO1_MSG_PENDING);
    CAN_ConfigFilter();
}

// === CAN Filter Configuration ===
void CAN_ConfigFilter(void)
{
    CAN_FilterTypeDef filter;

    filter.FilterActivation = CAN_FILTER_ENABLE;
    filter.FilterBank = 10;
    filter.FilterFIFOAssignment = CAN_FILTER_FIFO1;
    filter.FilterIdHigh = 0x0000;
    filter.FilterIdLow = 0x0000;
    filter.FilterMaskIdHigh = 0x0000;
    filter.FilterMaskIdLow = 0x0000;
    filter.FilterMode = CAN_FILTERMODE_IDMASK;
    filter.FilterScale = CAN_FILTERSCALE_32BIT;
    filter.SlaveStartFilterBank = 0;

    HAL_CAN_ConfigFilter(&hcan, &filter);
}

// === CAN Send Function ===
HAL_StatusTypeDef CAN_Send(uint16_t StdID, uint8_t* data, uint8_t len)
{
    TxHeader.StdId = StdID;
    TxHeader.IDE = CAN_ID_STD;
    TxHeader.RTR = CAN_RTR_DATA;
    TxHeader.DLC = len;

    return HAL_CAN_AddTxMessage(&hcan, &TxHeader, data, &TxMailbox);
}



//void Handle_CAN_TX(void){
//    uint16_t lclmsgLen[15]   ={0x500U,0x501U,0x502U,0x503U,0x580U,0x581U,
//                             0x588U,0x589U,0x58AU,0x190U,0x191U,0x192U,
//							 0x193U,0x194U,0x195U};
//    uint8_t msg[8] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};
//
//	for(uint8_t lclCnt=0; lclCnt<lclmsgLen[15]; lclCnt++){
//
//        CAN_Send(lclmsgLen[lclCnt], msg, 8);
//        HAL_Delay(100);
//
//	}
//}
void Handle_CAN_TX(void)
{
	CAN_TxHeaderTypeDef lclTxHeader;

	uint8_t lcldata8;
	uint16_t lcldata16;
	uint32_t lcldata32;
    uint16_t lclmsgLen[5] = { 0x600U,0x801U,0x102U,0x403U,0x550U };
    uint8_t msg[8] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};
    static uint8_t lclCnt = 0;
	lclTxHeader.IDE = CAN_ID_STD;
	lclTxHeader.RTR = CAN_RTR_DATA;
    lclTxHeader.TransmitGlobalTime = DISABLE;
    lclTxHeader.DLC = 8;  // default 8, can change per message
    lclCnt++;

		    switch (lclCnt) {
		        case 1: {
		            // Fill from struct STM_CAN_0x600
		            lclTxHeader.StdId = lclmsgLen[0];
		            STM_CAN_0x600.PA5_led = 1;
		            	.PA6_led = 0,
		                .data1 = 1,
		                .data2 = 0,
		                .data3 = 1,
		                .data4 = 0,
		                .data5 = 1,
		                .data6 = 0,
		                .ADC_data = 123,
		                .PWM_data = 456,
		                .plm_data = 789
		            };

		            msg[0] = *((uint8_t *)&can600);                 // Bitfields packed in 1 byte
		            msg[1] = can600.ADC_data;
		            msg[2] = (uint8_t)(can600.PWM_data & 0xFF);
		            msg[3] = (uint8_t)(can600.PWM_data >> 8);
		            msg[4] = (uint8_t)(can600.plm_data & 0xFF);
		            msg[5] = (uint8_t)(can600.plm_data >> 8);
		            msg[6] = 0;
		            msg[7] = 0;
		        } break;

		        case 2: {
		            // Fill from struct STM_CAN_0x801
		            lclTxHeader.StdId = lclmsgLen[1];
		            STM_CAN_0x801 can801 = {
		                .Anurag_age = 25,
		                .Anurag_marks = 90,
		                .AnuragPhNo5Dig = 12345,
		                .AnuragID = 2025
		            };

		            msg[0] = can801.Anurag_age;
		            msg[1] = can801.Anurag_marks;
		            msg[2] = (uint8_t)(can801.AnuragPhNo5Dig & 0xFF);
		            msg[3] = (uint8_t)(can801.AnuragPhNo5Dig >> 8);
		            msg[4] = (uint8_t)(can801.AnuragID & 0xFF);
		            msg[5] = (uint8_t)(can801.AnuragID >> 8);
		            msg[6] = 0;
		            msg[7] = 0;
		        } break;

		        case 3: {
		            // Fill from struct STM_CAN_0x102
		            lclTxHeader.StdId = lclmsgLen[2];
		            STM_CAN_0x102 can102 = {
		                .myPhoneNo = 9876543210ULL
		            };

		            memcpy(msg, &can102.myPhoneNo, 8);  // 64-bit phone number
		        } break;

		        case 4: {
		            // Fill from struct STM_CAN_0x403
		            lclTxHeader.StdId = lclmsgLen[3];
		            STM_CAN_0x403 can403 = {
		                .MyPasswoard = 0x11223344,
		                .MyID = 0x55667788
		            };

		            memcpy(msg, &can403, 8);
		        } break;

		        case 5: {
		            // Fill from struct BUSMas_CAN_0x550
		            lclTxHeader.StdId = lclmsgLen[4];
		            BUSMas_CAN_0x550 can550 = {
		                .PrashantPhNo = 77778888,
		                .PrashantID = 12345678
		            };

		            memcpy(msg, &can550, 8);
		        } break;

		        default:
		            lclCnt = 0;
		            return;
		    }

		    if (HAL_CAN_AddTxMessage(&hcan, &lclTxHeader, msg, &TxMailbox) != HAL_OK) {
		        // Error handling
		    }

		    HAL_Delay(10); // Optional small delay between frames
		}

		case 2:

		break;

		case 3:

		break;

		case 4:

		break;

		default;
		lclCnt = 0;
		break;
    		}
    }
}

// === CAN RX Callback ===
void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO1, &RxHeader, RxData);
    CAN_MessageReceived = 1;  // Flag set for main loop
}
